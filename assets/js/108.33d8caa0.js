(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{715:function(t,e,s){"use strict";s.r(e);var a=s(11),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),s("p",[t._v("在了解 setState 之前，先了解一下 React 中一个包装结构 "),s("strong",[t._v("Transaction")]),t._v(":")]),t._v(" "),s("p",[s("code",[t._v("事务Transaction")]),t._v(": 是 React 中的一个调用结构，用于包装一个方法，结构为: initialize - perform(method) - close。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作。")]),t._v(" "),s("h2",{attrs:{id:"setstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#setstate"}},[t._v("#")]),t._v(" setState")]),t._v(" "),s("p",[s("code",[t._v("setState")]),t._v(" 在 React 中用于修改状态，更新视图，它由一下特点:")]),t._v(" "),s("ul",[s("li",[t._v("异步与同步: setState 并不是单纯的异步或同步，这与调用时的环境相关\n"),s("ul",[s("li",[t._v("在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState 是异步的\n"),s("ul",[s("li",[s("strong",[t._v("原因")]),t._v(": 因为在 setState 的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入 dirtyComponents 队列中等待执行；否则，开始执行 batchedUpdates 队列更新\n"),s("ul",[s("li",[t._v("在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而 componentDidUpdate 是在更新之后，此时组件已经不在事务流中了，因此则会同步执行")]),t._v(" "),s("li",[t._v("在合成事件中，React 是基于 "),s("strong",[t._v("事务流完成的事件委托机制")]),t._v(" 实现，也是处于事务流中")])])]),t._v(" "),s("li",[s("strong",[t._v("问题")]),t._v(": 无法在 setState 后马上从 this.state 上获取更新后的值")]),t._v(" "),s("li",[s("strong",[t._v("解决")]),t._v(": 如果需要马上同步去获取新值，setState(updater, callback) 其实是可以传入第二个参数的，在回调中即可获取最新值")])])]),t._v(" "),s("li",[t._v("在 原生事件 和 setTimeout 中，setState 是同步的，可以马上获取更新后的值\n"),s("ul",[s("li",[t._v("原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步")])])])])]),t._v(" "),s("li",[t._v("批量更新: 在 "),s("strong",[t._v("合成事件")]),t._v(" 和 "),s("strong",[t._v("生命周期钩子")]),t._v(" 中，setState 更新队列时，存储的是 "),s("strong",[t._v("合并状态(Object.assign)")]),t._v("。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新")]),t._v(" "),s("li",[t._v("函数式: 由于 "),s("strong",[t._v("Fiber")]),t._v(" 及 "),s("strong",[t._v("合并")]),t._v(" 的问题，官方推荐可以传入 "),s("strong",[t._v("函数")]),t._v(" 的形式。setState(fn) -> 在 fn 中返回新的 state 对象即可，例如this.setState((state, props) => newState)")])]),t._v(" "),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),s("ul",[s("li",[t._v("setState 合并，在 "),s("strong",[t._v("合成事件")]),t._v(" 和 "),s("strong",[t._v("生命周期钩子")]),t._v(" 中多次连续调用会被优化为一次；")]),t._v(" "),s("li",[t._v("当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法:\n"),s("ul",[s("li",[t._v("将数据挂载到外部，通过 props 传入，如放到 Redux 或父级中；")]),t._v(" "),s("li",[t._v("在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);