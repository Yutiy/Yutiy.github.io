(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{687:function(o,e,_){"use strict";_.r(e);var v=_(11),t=Object(v.a)({},(function(){var o=this,e=o.$createElement,_=o._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[_("p",[o._v("浏览器的本地存储主要分为 Cookie、WebStorage 和 IndexDB, 其中 WebStorage 又可以分为 localStorage 和 sessionStorage。接下来我们就来一一分析这些本地存储方案。")]),o._v(" "),_("h2",{attrs:{id:"cookie"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[o._v("#")]),o._v(" Cookie")]),o._v(" "),_("p",[_("code",[o._v("Cookie")]),o._v(" 最开始被设计出来其实并不是来做本地存储的，而是为了弥补 "),_("code",[o._v("HTTP")]),o._v(" 在"),_("strong",[o._v("状态管理上的不足")]),o._v("。")]),o._v(" "),_("p",[o._v("HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？这种背景下，就产生了 "),_("code",[o._v("Cookie")]),o._v("。")]),o._v(" "),_("p",[o._v("Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。")]),o._v(" "),_("p",[o._v("Cookie 的作用很好理解，就是用来做"),_("strong",[o._v("状态存储")]),o._v("的，但它也是有诸多致命的缺陷的：")]),o._v(" "),_("ul",[_("li",[o._v("容量缺陷: Cookie 的体积上限只有"),_("strong",[o._v("4KB")]),o._v("，只能用来存储少量的信息。")]),o._v(" "),_("li",[o._v("性能缺陷: Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。")]),o._v(" "),_("li",[o._v("安全缺陷: 由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。")])]),o._v(" "),_("h2",{attrs:{id:"localstorage"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#localstorage"}},[o._v("#")]),o._v(" localStorage")]),o._v(" "),_("p",[_("strong",[o._v("与Cookie异同")])]),o._v(" "),_("p",[o._v("localStorage 有一点跟 Cookie 一样，就是针对一个域名，即在同一个域名下，会存储相同的一段 localStorage。")]),o._v(" "),_("p",[o._v("不过它相对Cookie还是有相当多的区别的:")]),o._v(" "),_("ul",[_("li",[o._v("容量: localStorage 的容量上限为"),_("strong",[o._v("5M")]),o._v("，相比于Cookie的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。")]),o._v(" "),_("li",[o._v("只存在客户端: 默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的"),_("strong",[o._v("性能问题")]),o._v("和"),_("strong",[o._v("安全问题")]),o._v("。")]),o._v(" "),_("li",[o._v("接口封装: 通过 localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。")])]),o._v(" "),_("p",[_("strong",[o._v("应用场景")])]),o._v(" "),_("p",[o._v("利用 localStorage 的较大容量和持久特性，可以利用 localStorage 存储一些内容稳定的资源，比如官网的 logo，存储 Base64 格式的图片资源，因此利用 localStorage")]),o._v(" "),_("h2",{attrs:{id:"sessionstorage"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sessionstorage"}},[o._v("#")]),o._v(" sessionStorage")]),o._v(" "),_("p",[o._v("sessionStorage 以下方面和 localStorage一致:")]),o._v(" "),_("ul",[_("li",[o._v("容量: 容量上限也为 5M。")]),o._v(" "),_("li",[o._v("只存在客户端: 默认不参与与服务端的通信。")]),o._v(" "),_("li",[o._v("接口封装: 除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样。")])]),o._v(" "),_("p",[o._v("但 sessionStorage 和 localStorage 有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分 sessionStorage 就不复存在了。")]),o._v(" "),_("p",[_("strong",[o._v("应用场景")])]),o._v(" "),_("ol",[_("li",[o._v("可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。")]),o._v(" "),_("li",[o._v("可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博就采取了这样的存储方式。")])]),o._v(" "),_("h2",{attrs:{id:"indexdb"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#indexdb"}},[o._v("#")]),o._v(" IndexDB")]),o._v(" "),_("p",[_("code",[o._v("IndexDB")]),o._v(" 是运行在浏览器中的 "),_("code",[o._v("非关系型数据库")]),o._v(", 本质上是数据库，绝不是和刚才 WebStorage 的 5M 一个量级，理论上这个容量是没有上限的。")]),o._v(" "),_("p",[o._v("使用文档"),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB",target:"_blank",rel:"noopener noreferrer"}},[o._v("MDN"),_("OutboundLink")],1),o._v("， 接着我们来分析一下IndexDB的一些重要特性，除了拥有数据库本身的特性，比如"),_("code",[o._v("支持事务，存储二进制数据")]),o._v("，还有这样一些特性需要格外注意：")]),o._v(" "),_("ul",[_("li",[o._v("键值对存储: 内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。")]),o._v(" "),_("li",[o._v("异步操作: 数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。")]),o._v(" "),_("li",[o._v("受同源策略限制: 即无法访问跨域的数据库。")])])])}),[],!1,null,null,null);e.default=t.exports}}]);