---
title: '判断元素进入可视区viewport'
date: 2020-03-26
permalink: 'html/viewport'
tag:
  - html
categories:
  - html
---

## 客户区大小

**客户区大小是只读的**，每次访问都要重新计算的:

| 客户区大小 | 概念 | 公式 |
| ---------- | --------- | ----- |
| clientWidth  | 元素内容区宽度加 上左右内边距宽度 | clientWidth = content + padding  |
| clientHeight | 元素内容区高度加上上下内边距高度  | clientHeight = content + padding |

> 注意在 IE7 以前的版本中，需要通过 `document.compatMode == "BackCompat"` 为 true 检查获取的位置是从 document.body 处获取，否则从 document.documentElement 处获取。


## 偏移量

**偏移量也是只读的**，元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小(**注意，不包括外边距**)。通过下列4个属性可以取得元素的偏移量:

| 偏移量 | 概念 | 公式 |
| ---------- | --------- | ----- |
| offsetHeight | 元素在垂直方向上占用的空间大小，以像素计。包括元素的高度、(可见的) 水平滚动条的高度、上边框高度和下边框高度 | offsetHeght = content + padding + border + scrollX |
| offsetWidth  | 元素在水平方向上占用的空间大小，以像素计。包括元素的宽度、(可见的)垂 直滚动条的宽度、左边框宽度和右边框宽度 | offsetWidth = content + padding + border + scrollY |
| offsetLeft   | 元素的左外边框至**包含元素的左内边框之间的像素距离** | |
| offsetTop    | 元素的上外边框至包含元素的上内边框之间的像素距离     | |

其中，offsetLeft 和 offsetTop 属性与包含元素有关，包含元素的引用保存在 offsetParent 属性中。**offsetParent 属性不一定与 parentNode 的值相等**。

## 滚动大小

| 滚动大小 | 概念 |
| ---------- | --------- |
| scrollHeight | 在没有滚动条的情况下，元素内容的总高度 |
| scrollWidth  | 在没有滚动条的情况下，元素内容的总宽度 |
| scrollLeft   | 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置 |
| scrollTop    | 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置 |

scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小。

scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于 0。如果元素被垂直滚动了，那么 scrollTop 的值 会大于 0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么 scrollLeft 的值会 大于 0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的 scrollLeft 和 scrollTop 设置为 0，就可以重置元素的滚动位置。

## 确定元素大小

**getBoundingClientRect**: 返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有 left, top, right, bottom, x, y, width。

> 兼容性问题

getBoundingClientRect() 最先是IE的私有属性，现在已经是一个W3C标准。所以你不用当心浏览器兼容问题，不过还是有区别的：

- IE只返回 top,left,right,bottom 四个值
- 可以通过以下方法来获取 width,height 的值: `const width = rect.right - rect.left; const height = ro.bottom - ro.top;`.

> 获取页面元素的位置

绝大多数情况下，可以使用元素的 offsetParent 来获取在页面中其位置:

```js
var _x = 0, _y = 0;

do {
  _x += el.offsetLeft;
  _y += el.offsetTop;
} while(el = el.offsetParent);

return { x: _x, y: _y };
```

使用 getBoundingClientRect 这个方法，获取页面元素的位置就简单多了:

```js
const rect = element.getBoundingClientRect();
const x = rect.left + document.documentElement.scrollLeft;
const y = rect.top + document.documentElement.scrollTop;
```

## 判断元素是否在可视区

判断公式: **el.offsetTop - document.documentElement.scrollTop <= viewPortHeight**

```js
function isElementInViewport (el) {
  const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
  const top = el.offsetTop - document.documentElement.scrollTop;

  // 这里 +100 是为了提前加载 +100
  return top <= viewPortHeight + 100
}
```

其中 `el.offsetTop - document.documentElement.scrollTop` 可以使用 `el.getBoundingClientRect().top` 替代。

还有一种判断公式: **intersectionRatio > 0 && intersectionRatio <= 1**，如懒加载可写法如下:

```js
// 定义一个交叉观察器
const io = new IntersectionObserver(ioes => {
  ioes.forEach(ioe => {
    const el = ioe.target
    const intersectionRatio = ioe.intersectionRatio
    if (intersectionRatio > 0 && intersectionRatio <= 1) {
      loadImg(el)
      io.unobserve(el)
    }
    el.onload = el.onerror = () => io.unobserve(el)
  })
})

// 执行交叉观察器
function isElementInViewport(el) {
  io.observe(el)
}
```
