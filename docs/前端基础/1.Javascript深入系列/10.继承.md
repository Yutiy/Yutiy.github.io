---
title: '继承'
date: 2020-03-26
permalink: 'js_deep/extend'
tag:
  - javascript基础系列
categories:
  - javascript基础系列
---

## 1. 构造函数绑定

```js
function Parent(name) {
  this.name = name;
  this.likes = ['front', 'game'];
}

function Child(name) {
  Parent.call(this, name);
}

var child1 = new Child('yutiy');
child1.likes.push('sleep');

console.log(child1.name); // yutiy
console.log(child1.likes); // ["front", "game", "sleep"]

var child2 = new Child('kevin');
console.log(child2.likes); // ["front", "game"]
```

优点:

1. 避免了引用类型的属性被所有实例共享
2. 可以在 Child 中向 Parent 传参

缺点:

方法都在构造函数中定义，每次创建实例都会创建一遍方法

## 2. 原型链继承

```js
function Person() {
  this.name = 'yutiy';
}

Person.prototype.getName = function() {
  return this.name;
}

function Child() {}
Child.prototype = new Person();
Child.prototype.constructor = Child;  // 修正构造函数指向

var child1 = new Child();
console.log(child1.name);   // yutiy
```

缺点:

1. 引用类型的属性会被所有实例共享，如:

```js
function Parent () {
  this.names = ['kevin', 'daisy'];
}

function Child() {}

Child.prototype = new Parent();
var child1 = new Child();

child1.names.push('yayu');
console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();
console.log(child2.names); // ["kevin", "daisy", "yayu"]
```

2. 在创建 Child 实例时，不能向 Parent 传参

## 3. 组合继承

原型链继承和构造函数绑定的融合

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('kevin', '18');
child1.colors.push('black');

console.log(child1.name); // kevin
console.log(child1.age); // 18
console.log(child1.colors); // ["red", "blue", "green", "black"]

var child2 = new Child('daisy', '20');

console.log(child2.name); // daisy
console.log(child2.age); // 20
```

缺点:

1. 会调用两次父类构造函数，分别是设置子类型实例的原型 `Child.prototype = new Parent();` 和创建子类型实例 `var child1 = new Child('kevin', '18');`
2. Child.prototype 上面创建了不必要的、多余的属性

## 4. 直接继承prototype

效率较高，不要执行和创建 Parent 实例

```js
function Parent() {
  this.name = 'yutiy';
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child() {
  Parent.call(this);
}
Child.prototype = Parent.prototype;
Child.prototype.constructor = Child;
```

缺点:

1. 修改 constructor 后，Parent 的 constructor 会错误指向 Child

## 5. 寄生组合式继承

利用一个空对象作为中介修复 **直接继承prototype** 方式的缺点，并且 F 是空对象，所以几乎不占用内存，这时，修改 Child 的 prototype 对象，就不会影响到 Parent 的 prototype 对象

```js
function Parent() {
  this.name = 'yutiy';
  this.colors = ['red', 'blue', 'green'];
}

Parent.prototype.getName = function () {
  console.log(this.name)
}

function Child (name, age) {
  Parent.call(this, name);
  this.age = age;
}

extend(Child, Parent);

function extend(Child, Parent) {
  var F = function(){};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
  Child.uber = Parent.prototype;
}
```

1. 只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性
2. 原型链保持不练，可以正常使用 instanceof 和 isPrototypeOf
