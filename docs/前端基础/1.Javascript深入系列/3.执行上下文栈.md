---
title: '执行上下文栈'
date: 2020-03-26
permalink: 'js_deep/execution_stack'
tag:
  - javascript深入系列
categories:
  - javascript深入系列
---

## 可执行代码

Javascript 的可执行代码分为三种: 全局代码、函数代码、eval代码。

举个🌰，当执行到一个函数时，就会进行一些准备工作，用专业点的说法就是**执行上下文(execution context)**。

## 执行上下文栈

Javascript 引擎会创建执行上下文栈来管理执行上下文。为了模拟上下文栈的行为，让我们定义执行上下文栈是一个数组:

```js
ECStack = [];
```

试想当 Javascript 要开始解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文（globalContext），且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext:

```js
ECStack = [globalContext]
```

现在 JavaScript 遇到下面的这段代码了：

```js
function func3() {
  console.log('func3');
}

function func2() {
  func3();
}

function func1() {
  func2();
}

func1();
```

当执行一个函数的时候，就会创建一个上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码:

```js
// 伪代码

// func1
ECStack.push(func1Context);

// fun1中竟然调用了fun2，还要创建fun2的执行上下文
ECStack.push(func2Context);

// fun2中竟然调用了fun3，还要创建fun3的执行上下文
ECStack.push(func3Context);

// func3执行完毕
ECStack.pop();

// func2执行完毕
ECStack.pop();

// func1执行完毕
ECStack.pop();

// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

## 解答思考题

看一下上篇文章[词法作用域和动态作用域](./2.词法作用域和动态作用域.md)提到的思考题:

```js
var scope = "global scope";
function checkscope(){
  var scope = "local scope";
  function f(){
    return scope;
  }
  return f();
}
checkscope();

// demo2
var scope = "global scope";
function checkscope(){
  var scope = "local scope";
  function f(){
    return scope;
  }
  return f;
}
checkscope()();
```

到底哪里不同呢，答案就是执行上下文栈不一样。

模拟第一段代码如下:

```js
ECStack.push(checkScopeFunctionContext);
ECStack.push(fFunction());
ECStack.pop();
ECStack.pop();
```

模拟第二段代码如下:

```js
ECStack.push(checkScopeFunctionContext);
ECStack.pop();
ECStack.push(fFunction());
ECStack.pop();
```

为了更详细的讲述两个函数执行上的区别，还需要探究执行上下文到底包含那些内容，具体可以查看后续几篇文章。

## 参考

[JavaScript深入之执行上下文栈](https://github.com/mqyqingfeng/Blog/issues/4)
