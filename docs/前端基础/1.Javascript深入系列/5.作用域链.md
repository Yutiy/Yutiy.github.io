---
title: '作用域链'
date: 2020-03-26
permalink: 'js_deep/scope_chain'
tag:
  - javascript深入系列
categories:
  - javascript深入系列
---

在[变量对象](./4.变量对象.md)中讲到，当查找变量时，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直查到全局上下文的变量对象，也就是全局对象。

这样由多个执行上下文的变量对象构成的链表就叫做作用域链。下面以一个函数的创建和激活两个时期来讲解作用域链时如何创建和变化的。

## 函数创建

在[词法作用域和动态作用域](./2.词法作用域和动态作用域.md)中讲到，函数的作用域在创建的时候就确定了。

这是因为函数中又一个内部属性 [[scope]], 当函数被创建的时候，就会保存所有父变量对象到其中，可以理解 [[scope]] 就是所有父变量对象的层级链。但是注意: [[scope]] 并不代表完整的作用域链!!

举个🌰:

```js
function foo() {
  function bar() {
    // pass
  }
}
```

当函数创建时，各自的 scope 为:

```js
foo.[[scope]] = [
  globalContext.VO
]

bar.[[scope]] = [
  fooContext.AO,
  globalContext.VO,
]
```

## 函数激活

当函数激活时，进入函数上下文，创建VO/AO后，就会将活动对象添加到作用域的前端。

这时候执行上下文的作用域链，命名为 Scope, 至此，作用域链创建完毕:

```js
Scope = [AO].concat([[scope]])
```

## 举个🌰

以下面函数的执行为例，看看执行过程是怎样的。

```js
var scope = "global scope"
function checkScope() {
  var scope2 = "local scope";
  return scope2;
}
checkScope();
```

1. checkScope函数被创建，保存作用域链到内部属性[[scope]]

```js
checkScope.[[scope]] = [
  globalContext.VO
]
```

2. 执行 checkScope 函数，创建 checkScope 函数执行上下文，checkScope 函数执行上下文被压入执行上下文栈

```js
ECStack = [
  checkScopeContext,
  globalContext,
]
```

3. checkScope函数并不立即执行，开始做准备工作，首先复制 [[scope]] 属性创建作用域链

```js
checkScopeContext = {
  Scope: checkScope.[[scope]],
}
```

4. 然后用 argument 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明

```js
checkScopeContext = {
  AO: {
     arguments: {
      length: 0,
    },
    scope2: undefined,
  }
  Scope: checkScope.[[scope]]
}
```

5. 最后，将活动对象压入 checkScope 作用域链顶端

```js
checkScopeContext = {
  AO: {
    arguments: {
      length: 0,
    },
    scope2: "local scope",
  },
  Scope: checkScope.[[scope]]
}
```

6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

```js
checkScopeContext = {
  AO: {
    arguments: {
      length: 0
    },
    scope2: "local scope"
  },
  Scope: [AO, [[Scope]]]
}
```

7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出

```js
ECStack = [
  globalContext
]
```

## 参考

[Javascript深入之作用域链](https://github.com/mqyqingfeng/Blog/issues/6)
