---
title: 'ArrowFunc'
date: 2020-03-26
permalink: 'es6_arrowFunc'
tag:
  - ES6
categories:
  - ES6
---

箭头函数与普通函数的区别:

## 1. 没有this

函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

```js
function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() => this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0

// 不能用 call()、apply()、bind() 这些方法改变 this 的指向
var value = 1;
var result = (() => this.value).bind({value: 2})();
console.log(result); // 1
```

## 2. 没有arguments

箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：

```js
function constant() {
  return () => arguments[0];
}

var result = constant(1);
console.log(result()); // 1
```

那如果就是要访问箭头函数的参数呢？可以通过命名函数或者 rest 参数的形式访问参数:

```js
let nums = (...nums) => nums;
```

## 3. 不能通过new关键字调用

JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。

- 当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。
- 当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。
- 箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。

```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```

## 4. 没有 new.target

因为不能使用 new 调用，所以也没有 new.target 值。

关于 new.target，可以参考 [http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7](http://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7)

## 5. 没有原型及、super

由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。

连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。

```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

## 6. 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数
