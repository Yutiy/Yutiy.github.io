---
title: 'Map'
date: 2020-03-26
permalink: 'es6_map'
tag:
  - ES6
categories:
  - ES6
---

## 字典Map

**只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。**

```js
const map = new Map()

map.set(['a'], 555)
map.get(['a']) // undefined
```

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

```js
let map = new Map()

map.set(-0, 123)
map.get(+0) // 123

map.set(true, 1)
map.set('true', 2)
map.get(true) // 1

map.set(undefined, 3)
map.set(null, 4)
map.get(undefined) // 3

map.set(NaN, 123)
map.get(NaN) // 123
```

### 属性

- constructor：构造函数
- size：返回字典中所包含的元素个数

```js
const map = new Map([
  ['name', 'Yutiy'],
  ['like', 'Front']
])
map.size // 2
```

### 方法

操作方法：

- set(key, value)：向字典中添加新元素
- get(key)：通过键查找特定的数值并返回
- has(key)：判断字典中是否存在键key
- delete(key)：通过键 key 从字典中移除对应的数据
- clear()：将这个字典中的所有元素删除

遍历方法

- keys()：将字典中包含的所有键名以迭代器形式返回
- values()：将字典中包含的所有数值以迭代器形式返回
- entries()：返回所有成员的迭代器
- forEach()：遍历字典的所有成员

```js
const map = new Map([
  ['name', 'Yutiy'],
  ['like', 'Front']
]);

console.log(map.entries()) // MapIterator {"name" => "Yutiy", "like" => "Front"}
console.log(map.keys()) // MapIterator {"name", "like"}
```

Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。

```js
map[Symbol.iterator] === map.entries // true
```

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。举个🌰：

```js
const reporter = {
  report: function(key, value) {
    console.log("Key: %s, Value: %s", key, value)
  }
};

let map = new Map([
  ['name', 'Yutiy'],
  ['like', 'Front']
])
map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);

// Key: name, Value: Yutiy
// Key: like, Value: Front
```

> 与其他数据结构的相互转换

1. **Map 转 Array**

```js
const map = new Map([[1, 1], [2, 2], [3, 3]])
console.log([...map])	// [[1, 1], [2, 2], [3, 3]]
```

2. **Array 转 Map**

```js
const map = new Map([[1, 1], [2, 2], [3, 3]])
console.log(map)	// Map {1 => 1, 2 => 2, 3 => 3}
```

3. **Map 转 Object**

因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。

```js
function mapToObj(map) {
  let obj = Object.create(null)
  for (let [key, value] of map) {
    obj[key] = value
  }
  return obj
}
const map = new Map().set('name', 'Yutiy').set('like', 'Front')
mapToObj(map) // {name: "Yutiy", like: "Front"}
```

4. **Object 转 Map**

```js
function objToMap(obj) {
  let map = new Map()
  for (let key of Object.keys(obj)) {
    map.set(key, obj[key])
  }
  return map
}

objToMap({'name': 'Yutiy', 'like': 'Front'}) // Map {"name" => "An", "des" => "JS"}
```

5. **Map 转 JSON**

```js
function mapToJson(map) {
  return JSON.stringify([...map])
}

let map = new Map().set('name', 'Yutiy').set('like', 'Front')
mapToJson(map) // [["name","An"],["des","JS"]]
```

6. **JSON 转 Map**

```js
function jsonToStrMap(jsonStr) {
  return objToMap(JSON.parse(jsonStr));
}
jsonToStrMap('{"name": "Yutiy", "like": "Front"}') // Map {"name" => "An", "des" => "JS"}
```

## WeakMap

> WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。

**WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。**

WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。

### 属性：

- constructor：构造函数

### 方法：

- has(key)：判断是否有 key 关联对象
- get(key)：返回key关联对象（没有则则返回 undefined）
- set(key)：设置一组key关联对象
- delete(key)：移除 key 的关联对象

```js
let myWeakmap = new WeakMap()
let myElement = document.getElementById('logo')

myWeakmap.set(myElement, { timesClicked: 0 })
myElement.addEventListener('click', function() {
  let logoData = myWeakmap.get(myElement)
  logoData.timesClicked++
}, false)
```
