---
title: 'defineProperty与Proxy'
date: 2020-03-26
permalink: 'es6_proxy'
tag:
  - ES6
categories:
  - ES6
---

## defineProperty

该方法可以在一个对象上面定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。

**语法**

> Object.defineProperty(obj, prop, descriptor);

**参数**

- obj: 要在其上面定义属性的对象
- prop: 要定义或修改的属性名称
- description: 将被定义或修改的属性的描述符

举个🌰 :

```js
var obj = {};

// 对象 obj 拥有属性 num，其值为 1
Object.defineProperty(obj, 'num', {
  value: 1,
  writable: true,
  enumerable: true,
  configurable: true
})
```

函数的第三个参数 descriptor 所表示的属性描述符有两种形式: **数据描述符和存取描述符**。

*两者均具有以下两种键值*:

**configurable**

```
当且仅当该属性 configurable 为 true 时，该属性描述符才能够被改变，也能够被删除。默认为 false。
```

**enumerable**

```
当且仅当该属性 enumerable 为 true 时，该属性才能出现在对象的枚举属性中。默认为 false。
```

*数据描述符同时具有一下可选键值*:

**value**

```
该属性对应的值。可以是任何有效的 Javascript 值（数值、对象、函数等）。默认为 undefined。
```

**writable**

```
当且仅当该属性 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。
```

*存取描述符同时具有一下可选键值*:

**get**

```
一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。
```

**set**

```
一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。
```

值得注意的是: **属性描述符必须是数据描述符或者存取描述符两种形式之一，不能同时是两者。另外所有的属性描述符都是非必须的，但是 descriptor 这个字段是必须的。**。

## watch API

既然可以监控数据改变，那设想当数据改变的时候，页面就可以自动渲染工作。举个🌰 ：

HTML中有个 span 标签和 button 标签，当点击按钮时，span 标签里的值加 1。

```html
<span id="container">1</span>
<button id="button">点击加 1</button>
```

传统的做法是:

```js
var container = document.getElementById('container');
document.getElementById('button').addEventListener('click', function() {
  container.innerHTML = Number(container.innerHTML) + 1;
}, false);
```

如果使用了 defineProperty：

```js
var obj = {
  value: 1
}

// 储存 obj.value 的值
var value = 1;
var container = document.getElementById('container');

Object.defineProperty(obj, "value", {
  get: function() {
    return value;
  },
  set: function(newVal) {
    value = newVal;
    container.innerHTML = newVal;
  }
});

document.getElementById('button').addEventListener("click", function() {
  obj.value += 1;
});
```

代码增多了，但是更改的时候只要直接修改 obj.value 值就可以了。

但是现在的写法，还需要单独声明一个变量存储 obj.value 值，因为如果在 set 中直接 `obj.value = newVal` 就会陷入无限循环中。此外可能需要监控多个属性值改变，为避免繁琐，所以简写一个 watch 函数，如下：

```js
(function() {
  var root = this;
  function watch(obj, name, func) {
    var value = obj[name];

    defineProperty(obj, name, {
      get: function() {
        return value;
      },
      set: function(newVal) {
        value = newVal;
        func(value);
      }
    })

    if (value) obj[name] = value;
  }

  this.watch = watch;
})();
```

然后使用如下:

```js
var obj = { value: 1 };
var container = document.getElementById('container');

watch(obj, 'value', function(newVal) {
  container.innerHTML = newVal;
})

document.getElementById('button').addEventListener('click', function() {
  obj.value += 1;
}, false);
```

## Proxy

使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。

**语法**

> var proxy = new Proxy(target, handler);

**说明**
- new Proxy(): 生成一个 Proxy 实例
- target：参数表示所要拦截的目标对象
- handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。

举个🌰 :

```js
var target = { _prop: 'foo', prop: 'foo' };
var proxy = new Proxy(target, {
  get: function(obj, prop) {
    console.log('设置 get 操作')
    return obj[prop];
  },
  set: function(obj, prop, value) {
    console.log('设置 set 操作')
    obj[prop] = value;
  },

  // 使用 has 方法隐藏某些属性，不被 in 运算符发现
  has (target, key) {
    if (key[0] === '_') {
      return false;
    }
    return key in target;
  }
});

proxy.time = 35; // 设置 set 操作
console.log(proxy.time); // 设置 get 操作 // 35
console.log('_prop' in proxy); // false
```

proxy 可以拦截多达 13 种操作，比如说 ownKeys 方法可以拦截对象自身属性的读取操作。具体来说，拦截以下操作：

- Object.getOwnPropertyNames()
- Object.getOwnPropertySymbols()
- Object.keys()

下面的例子是拦截第一个字符为下划线的属性名，不让它被 for of 遍历到。

```js
let target = {
  _bar: 'foo',
  _prop: 'bar',
  prop: 'baz'
};

let handler = {
  ownKeys(target) {
    return Reflect.ownKeys(target).filter(key => key[0] !== '_');
  }
};

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) {
  console.log(target[key]);
}
// "baz"
```

更多的拦截行为可以查看阮一峰老师的 [《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#docs/proxy)

值得注意的是，proxy 的最大问题在于浏览器支持度不够，而且很多效果无法使用 poilyfill 来弥补。

## watch API优化

我们使用 proxy 再来写一下 watch 函数。使用效果如下：

```js
(function() {
  var root = this;
  function watch(target, func) {
    var proxy = new Proxy(target, {
      get: function(target, prop) {
        return target[prop];
      },
      set: function(target, prop, value) {
        target[prop] = value;
        func(prop, value);
      }
    });
    return proxy;
  }

  this.watch = watch;
})()

var obj = {
  value: 1
}

var container = document.getElementById('container');
var newObj = watch(obj, function(key, newVal) {
  if(key == 'value') container.innerHTML = newVal;
})

document.getElementById('button').addEventListener("click", function() {
  newObj.value += 1;
}, false);
```

## 总结

- 使用 defineProperty，我们修改原来的 obj 对象就可以触发拦截
- 使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截
