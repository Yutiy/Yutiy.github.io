---
title: 'Generator'
date: 2020-03-26
permalink: 'es6/generator'
tag:
  - ES6
categories:
  - ES6
---

执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。

形式上，Generaotr 函数是一个普通函数，但是有两个特征:

- function 关键字与函数名之间有一个星号
- 函数体内部使用 yield 表达式，定义不同的内部状态

## 使用

Generator 函数会返回一个遍历器对象，即具有 Symbol.iterator 属性，并且返回给自己:

```js
function *gen() {
  // pass
}

var g = gen();
g[Symbol.iterator]() === g // true
```

通过 yield 关键字可以暂停 generator 函数返回遍历器对象的状态:

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
```

上述存在三个状态: `hello`、`world`、`return`

通过 `next` 方法才会遍历到下一个内部状态，其运行逻辑如下:

- 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后米娜的那个表达式的值作为返回对象的 value 属性值
- 下一次吊用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式
- 如果没有再遇到新的 yield 表达式，就一只运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值作为返回对象的 value 属性值
- 如果该函数没有 return 语句，则返回对象的 value 属性值为 undefined

```js
hw.next() // { value: 'hello', done: false }
hw.next() // { value: 'world', done: false }
hw.next() // { value: 'ending', done: false }
hw.next() // { value: undefined, done: false }
```

- `done` 是用来判断是否存在下个状态，`value` 为对应状态值。
- `yield` 表达式本身没有返回值，或者说总是返回 undefined
- `next` 方法可以带一个参数，该参数会被当作上一个 `next` 表达式的返回值

```js
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

var a = foo(5);
a.next(); // { value: 6, done: false }
a.next(); // { value: NaN, done: false }
a.next(); // { value: NaN, done: true }

var b = foo(5);
b.next(); // { value: 6, done: false }
b.next(12); // { value: 8, done: false }
b.next(13); // { value: 42, done: true }
```

因为 Generator 函数返回 Iterator 对象，因此还可以通过 for...of 进行遍历:

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

原生对象没有遍历接口，通过 Generator 函数加上该接口，就能使用 for...of 遍历了:

```js
function *objectEntries(obj) {
  const propKeys = Reflect.ownKeys(obj);
  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]]
  }
}

let jane = { first: 'Jane', last: 'Doe' };
for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```
