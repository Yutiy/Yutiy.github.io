---
title: 'Promise'
date: 2020-03-26
permalink: 'es6/promise'
tag:
  - ES6
categories:
  - ES6
---

## Promise是什么

> Promise并不指特定的某个实现，它是一种规范，是一套处理JavaScript异步的机制。[Promises/A+规范](http://www.ituring.com.cn/article/66566)

## PromiseA+规范

1. new Promise时，需要传递一个 executor 执行器，执行器立刻执行
2. executor 接受两个参数，分别是 resolve 和 reject
3. promise 只能从 pending 到 rejected, 或者从 pending 到 fulfilled
4. promise 的状态一旦确认，就不会再改变
5. promise 都有 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected
6. 如果调用 then 时，promise 已经成功，则执行 onFulfilled，并将 promise 的值作为参数传递进去。
   如果 promise 已经失败，那么执行 onRejected, 并将 promise 失败的原因作为参数传递进去。
   如果 promise 的状态是pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行(发布订阅)
7. then 的参数 onFulfilled 和 onRejected 可以缺省
8. promise 可以 then 多次，promise 的 then 方法返回一个 promise
9. 如果 then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调(onFulfilled)
10. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调(onRejected)
11. 如果 then 返回的是一个 promise, 那么需要等这个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功，如果失败，就走下一个 then 的失败

## 基本架构

```js
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

function Promise(callback) {
  var _this = this;
  _this.value = void 0;   // Promise的值
  _this.currentState = PENDING;   // Promise当前状态

  // 用于保存 then 回调，只有当 promise 状态为 pending 时才会缓存，并且每个实例至多缓存一个
  _this.onResolvedCallbacks = [];
  _this.onRejectedCallbacks = [];

  // 处理函数
  _this.resolve = function(value) {
    if (value instanceof Promise) {   // 如果 value 是 Promise，递归执行
      return value.then(_this.resolve, _this.reject);
    }

    setTimeout(function() {   // 异步执行，保证顺序执行
      if (_this.currentState === Pending) {
        _this.currentState = FULFILLED;
        _this.value = value;
        _this.onResolvedCallbacks.forEach(cb => cb());
      }
    })
  }
  _this.reject = function(value) {
    setTimeout(function() {
      if (_this.currentState === Pending) {
        _this.currentState = REJECTED;
        _this.value = value;
        _this.onRejectedCallbacks.forEach(cb => cb());
      }
    })
  }

  // 异常处理
  try {
    callback(_this.resolve, _this.reject);  // 执行callback并传入相应参数
  } catch(err) {
    _this.reject(err);
  }
}
```

## then、catch、finally实现

```js
// then 方法接收两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调
Promise.prototype.then = function(onFulfilled, onRejected) {
  var promise2;     // 2.2.7规范，then 必须返回一个新的 Promise
  var _this = this;
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function(value) { return value };
  onRejected = typeof onRejected === 'function' ? onRejected ? function(error) { throw error };

  if (_this.currentState === FULFILLED) {
    return promise2 = new Promise(function(resolve, reject) {
      // 2.2.4规范，使用 setTimeout 保证 onFulfilled, onRejected 异步执行
      setTimeout(function() {
        try {
          var x = onFulfilled(_this.value);

          // 如果返回值 x 是一个 Promise 对象，直接取结果作为 promise2 的结果，否则以它的返回值为 promise2 的结果
          if (x instanceof Promise) {
            x.then(resolve, reject);
          }
          resolve(x);
        } catch(err) {
          reject(err);
        }
      })
    })
  }

  // 实现与 FULFILLED 类似
  if (_this.currentState === REJECTED) {
    return promise2 = new Promise(function(resolve, reject) {
      setTimeout(function() {
        try {
          var x = onRejected(_this.value);
          if (x instanceof Promise) {
            x.then(resolve, reject);
          }
        } catch(err) {
          reject(err);
        }
      })
    })
  }

  // 如果当前 Promise 处于 PENDING 状态，此时并不能确定调用 onFulfilled 还是 onRejected，只能等 Promise 状态确定后，再做处理
  // 所以需要把两种情况的处理逻辑做成 callback 放入原 primise 的回调数组内，因此处理逻辑和以上类似
  if (_this.currrentState === PENDING) {
    return promise2 = new Promise(function(resolve, reject) {
      _this.onResolvedCallbacks.push(function() {
        try {
          var x = onFulfilled(_this.value);
          if (x instanceof Promise) {
            x.then(resolve, reject);
          }
          resolve(x);
        } catch(err) {
          reject(err)
        }
      })

      _this.onRejectedCallbacks.push(function() {
        try {
          var x = onRejected(_this.value);
          if (x instanceof Promise) {
            x.then(resolve, reject);
          }
        } catch(err) {
          reject(err)
        }
      })
    })
  }
}

Promise.prototype.catch = function(onRejected) {
  return this.then(null, onRejected);
}

Promise.prototype.finally = function(callback) {
  return this.then(
    function(value) {
      return Promise.reslove(callback()).then(function() {
        return value;
      })
    },
    function(err) {
      return Promise.reslove(callback()).then(function() {
        throw err;
      })
    }
  )
}
```

## 无缝调用

```js
function resolutionProcedure(promise2, x, resolve, reject) {
  // 2.3.1规范，x 不能和 promise2 相同，避免循环饮用
  if (promise2 === x) {
    return reject(new TypeError("Chaining cycle detected for promise!"));
  }

  // 2.3.2规范，如果 x 为 Promise，状态为 PENDING 需要继续等待否则执行
  if (x instanceof Promise) {
    // 2.3.2.1规范，如果 x 为 PENDING 状态，Promise必须继续保持该状态，直到状态更改
    if (x.currentState === PENDING) {
      x.then(function(value) {
        // 再次调用该函数是为了确认 x resolve 的参数是什么类型，如果是基本类型就再次 resolve， 把值传给下个 then
        resolutionProcedure(promise2, value, resolve, reject);
      }, reject);
    } else {
      // 但如果这个 Promise 的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态
      x.then(resolve, reject);
    }
    return;
  }

  var called = false;

  // 2.3.3规范，判断 x 是否为对象或函数
  if (x !== null && (typeof x === "object" || typeof x === "function")) {
    // 2.3.3.2规范，如果不能取出 then，就 reject
    try {
      // 2.3.3.1规范 因为 x.then 可能是一个getter，这种情况下多次读取就有可能产生副作用，既要判断它的类型，又要调用它，这就是两次读取
      let then = x.then;

      // 2.3.3.3规范，如果 then 是函数，调用 x.then
      if (typeof then === "function") {
        then.call(
          x,
          function(y) { // 2.3.3.3.1规范
            if (called) return; // 2.3.3.3.3规范，即这三处谁先执行就以谁的结果为准
            called = true;
            return resolutionProcedure(promise2, y, resolve, reject); // 规范 2.3.3.3.1
          },
          function(r) {
            if (called) return; // 2.3.3.3.3规范，即这三处谁先执行就以谁的结果为准
            called = true;
            return reject(r);
          },
        )
      } else {
        resolve(x); // 2.3.3.4规范
      }
    } catch(err) {  // 2.3.3.2规范
      if (called) return; // 2.3.3.3.3规范，即这三处谁先执行就以谁的结果为准
      called = true;
      return reject(err);
    }
  } else {
    // 2.3.4规范，x 为基本类型
    resolve(x);
  }
}
```

然后，我们使用resolutionProcedure函数替换MyPromise.prototype.then里面几处判断x是否为MyPromise对象的位置即可。即：

```js
if (x instanceof Promise) {
  x.then(resolve, reject);
}
```

总计 4 处替换为：

```js
resolutionProcedure(promise2, x, resolve, reject);
```

## Promise.race、Promise.all、Promise.allSettled实现

```js
Promise.race = function(values) {
  return new Promise(function(resolve, reject) {
    values.forEach(function(value) {
      Promise.reslove(value).then(resolve, reject);
    })
  })
}

Promise.all = function(arr) {
  var args = Array.prototype.slice.call(arr);
  return new Promise(function(resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }

    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          if (val.currentState === FULFILLED) return res(i, val.value);
          if (val.currentState === REJECTED) reject(val.value);
          val.then(function(val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function(val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
  })
}

// allSettled
Promise.allSettled = function(promises) {
  return new Promise(function(resolve, reject) {
    promises = Array.isArray(promises) ? promises : [];
    var len = promises.length;
    var argslen = len;
    if (len === 0) return resolve([]);
    var args = Array.prototype.slice.call(promises);

    for(var i = 0; i < argslen; i++){
      resolvePromise(i, args[i]);
    }

    function resolvePromise(index, value) {
      // 判断传入的是否是object
      if(typeof value === 'object') {
        var then = value.then;
        if(typeof then === 'function'){
          then.call(value, function(val) {
            args[index] = { status: FULFILLED, value: val};
            if(--len === 0) {
              resolve(args);
            }
          }, function(e) {
            args[index] = { status: REJECTED, reason: e };
            if(--len === 0) {
              reject(args);
            }
          })
        }
      }
    }
  })
}
```
