---
title: '图片懒加载实现'
date: 2020-03-26
permalink: 'img_lazyload'
tag:
  - performance
categories:
  - performance
---

## 一、采用 clientHeight、scrollTop 和 offsetTop

首先给图片一个占位资源:

```js
<img src="default.png" data-src="https://xxxx/real.png" />
```

接着通过监听 scroll 事件来判断图片是否到达视口:

```js
function isVisible(el) {
  let viewHeight = document.documentElement.clientHeight; // 视口高度
  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;  // 滚动条卷去的高度

  return el.offsetTop < viewHeight + scrollTop;
}

function lazyload() {
  const images = document.querySelectorAll('img')
  for (let img of images) {
    const realSrc = img.dataset.src
    if (!realSrc) continue
    if (isVisible(img)) {
      img.src = realSrc
      img.dataset.src = ''
    }
  }
}
```

最后对 scroll 事件做节流处理，以免频繁触发:

```js
window.addEventListener('load', lazyload)
window.addEventListener('scroll', throttle(lazyload, 1000))
```

## 二、getBoundingClientRect

用另外一种方式来判断图片是否出现在了当前视口, 即 DOM 元素的 getBoundingClientRect API。

改造上述 isVisible 方法如下:

```js
function isVisible(el) {
  const position = el.getBoundingClientRect()
  const windowHeight = document.documentElement.clientHeight;

  const topVisible = position.top > 0 && position.top < windowHeight; // 顶部边缘可见
  const bottomVisible = position.bottom < windowHeight && position.bottom > 0;  // 底部边缘可见

  return topVisible || bottomVisible
}
```

## 三、IntersectionObserver

这是浏览器内置的一个API，实现了`监听window的scroll事件`、`判断是否在视口中`以及`节流`三大功能。

```js
let img = document.querySelectorAll("img");

const observer = new IntersectionObserver(changes => {
  // changes 是被观察的元素集合
  for(let i = 0, len = changes.length; i < len; i++) {
    let change = changes[i];
    // 通过这个属性判断是否在视口中
    if(change.isIntersecting) {
      const imgElement = change.target;
      imgElement.src = imgElement.getAttribute("data-src");
      observer.unobserve(imgElement);
    }
  }
})

observer.observe(img);
```
