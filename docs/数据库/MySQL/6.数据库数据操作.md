---
title: '数据库数据操作'
date: 2020-03-26
permalink: 'mysql/database_data'
tag:
  - mysql
categories:
  - mysql
---

## 添加记录

`INSERT [INTO] tb_name [(col_name,...)] {VALUE|VALUES}(VALUES...);`

1. 不指定字段名称(需要按照建表时的字段顺序给每一个字段赋值) -> `INSERT tb_name VALUE(value...);`
2. 列出指定字段 -> `INSERT tb_name (字段名称,...) VALUES(值,...);`
3. INSERT ... SET的形式 -> `INSERT tb_name SET 字段名称=值,...;`
4. INSERT ... SELECT -> `INSERT tb_name [(字段名称...)] SELECT 字段名称,... FROM tb_name [WHERE 条件];`
5. 一次添加多条记录 -> `INSERT tb_name [(字段名称,...)] VALUES (值,...),(值,....),(值,...);`

## 修改记录

如果不添加条件，整个表中的记录都会被更新 -> `UPDATE tb_name SET 字段名称=值,字段名称=值 [WHERE 条件];`

## 删除记录

`DELETE FROM tb_name [WHERE 条件];`

- 如果不添加条件，表中所有记录都会被删除
- DELETE清空数据表的时候不会重置 **AUTO_INCREMENT** 的值，可以通过ALTER语句将其重置为1
- 彻底清空数据表(清除表中所有记录并重置AUTO_INCREMENT值，不能回滚) -> `TRUNCATE [TABLE] tb_name;`

## 查询记录

```mysql
SELECT select_expr,... FROM tb_name
[WHERE 条件]
[GROUP BY {col_name|position} HAVING 二次筛选]
[ORDER BY {col_name|position|expr} [ASC|DESC]]
[LIMIT 限制结果集的显示条数]
```

### 查询表中所有记录

`SELECT * FROM tb_name;`

### 提取指定字段信息

`SELECT 字段名,... FROM tb_name;`

### 库名.表名

`SELECT 字段名称,... FROM db_name.tb_name;`

### 给字段起别名

`SELECT 字段名称 [AS] 别名名称,... FROM tb_name;`

### 给数据表起别名

`SELECT 字段名称,... FROM tb_name [AS] 别名;`

### 表名.字段名

`SELECT tb_name.co_name,... FROM tb_name;`

### WHERE条件 -> 会筛选出符合条件的记录

- **比较运算符** -> `> >= < <= != <> <=>`, `<=> 和 = 的区别是 <=> 可以检测 NULL 值`
- **IS [NOT] NULL** -> `检测值是否为NULL或者NOT NULL`
- **指定范围** -> `[NOT] BETWEEN ... AND`
- **指定集合** -> `[NOT] IN(值,...)`
- **逻辑运算符** -> `AND、OR`
- **匹配字符(% -> 任意长度的字符串, - -> 任意一个字符)** -> `[NOT] LIKE`

### GROUP BY 分组

- 把值相同放到一个组中，最终查询出的结果只会显示组中一条记录
- 分组配合`GROUP_CONCAT()`查看组中某个字段的详细信息
- 配合WITH ROLLUP关键使用 -> 会在记录末尾添加一条记录，是上面所有记录的总和
- HAVING子句对分组结果进行二次筛选
- 配合聚合函数使用 -> `COUNT, SUM, AVG, MIN, MAX`

注意: **如果写的是COUNT(字段名称)，字段中的值为NULL，不统计进来, 写COUNT(*)会统计NULL值**

### ORDER BY 排序

`ORDER BY 字段名称 ASC|DESC`

### LIMIT 限制结果集显示条数

- LIMIT 值 -> 显示结果集的前几条记录
- LIMIT offset,row_count -> 从offset开始，显示几条记录,offset从0开始

## 多表查询

### 内连接形式

查询两个表中符合连接条件的记录 -> `SELECT 字段名称,... FROM tb_name1 INNER JOIN tb_name2 ON 连接条件;`

### 外连接的形式

- 左外连接 -> 先显示左表中的全部记录，再去右表中查询复合条件的记录，不符合的以NULL代替

`SELECT 字段名称,... FROM tb_name1 LEFT [OUTER] JOIN tb_name2 ON 条件;`

- 右外连接 -> 先显示右表中的全部记录，再去左表中查询复合条件的记录，不符合的以NULL代替

`SELECT 字段名称,... FROM tb_name1 RIGHT [OUTER] JOIN tb_name2 ON 条件;`

## 外键约束 -> 只有InnoDB存储引擎支持外键

### 建表时指定外键

`[CONSTRAINT 外键名称] FOREIGN KEY(字段名称) REFERENCES 主表(字段名称);`

- 子表的外键字段和主表的主键字段类型要相似；如果是数值型要求一致，并且无符号也要一致；如果是字符型，要求类型一致，长度可以不同
- 如果外键字段没有创建索引，MySQL会自动帮我们添加索引
- 子表的外键关联的必须是父表的主键

外键约束的参照操作:

- CASCADE -> 从父表删除或更新，子表也跟着删除或者更新，级联的操作
- SET NULL -> 从父表删除或者更新记录，并设置子表的外键列为NULL
- NO ACTION | RESTRICT -> 拒绝对父表做更新或者删除操作

### 动态添加外键

动态添加外键之前表中的记录一定合法的记录，没有脏值，否则外键添加不成功

`ALTER TABLE tb_name [CONSTRAINT 外键名称] ADD FOREIGN KEY(外键字段) REFERENCES 主表(主键字段);`

### 动态删除外键

`ALTER TABLE tb_name DROP FOREIGN KEY fk_name;`

## 特殊形式的查询

### 子查询

`SELECT 字段名称 FROM tb_name WHERE col_name=(SELECT col_name FROM tb_name)`

- 内层语句查询的结果可以做为外层语句查询的条件
- 由IN引发的子查询
- 由比较运算符引出子查询
- 由EXISTS引发的子查询
- ANY SOME ALL
- INSERT ... SELECT
- CREATE ... SELECT
- CREATE TABLE tbl_name LIKE tbl_name;

### 自身连接查询

无限级分类的实现形式

### 联合查询

UNION ALL 是简单的合并，UNION会去掉表中重复记录。

- UNION -> `SELECT 字段名称,... FROM tb_name1 UNION SELECT 字段名称... FROM tb_name2;`
- UNION ALL -> `SELECT 字段名称,... FROM tb_name1 UNION ALL SELECT 字段名称... FROM tb_name2;`
