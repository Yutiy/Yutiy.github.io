---
title: '用户、组和权限'
date: 2020-03-26
permalink: 'linux/perm'
tag:
  - linux
categories:
  - linux
---

# 用户和组信息的查看

在 `Linux` 中，用户可分为三类: 超级用户(root), 普通用户，程序用户。

- 超级用户: uid=0
- 程序用户: uid=1-999
- 普通用户: uid=1000-9999

## 查看用户信息

> cat /etc/passwd   # /etc/passwd默认权限为644，其最小权限为444

输出如:

- `root:x:0:0:root:/root:/bin/bash`
- `yutiy:x:1000:1000::/home/yutiy:/bin/bash`

用户信息显示的有 7 个字段，以 `root` 为例:

- 用户名: root
- 密码占位符: 统一用 x 替代
- 用户id: uid -> 0
- 组id: gid -> 0
- 用户描述信息:
- 家目录: /root
- 登录shell: /bin/bash 表示可以登录，/sbin/nologin 表示不被授权登陆

## 查看密码信息

> cat /etc/shadow   # shadow默认权限为600，最小权限为400

输出如:

- `root:$1$AKltJhnC$SsIJwBAj6v4DWzappfEhw/:18148:0:99999:7:::`
- `yutiy:$1$uBwuy6ub$EjqbmhgBpHawh1esWUgaj/:18150:0:99999:7:::`

密码信息显示的有 9 个字段，以 `root` 为例:

- 用户名
- 密码: 通过sha-512加密，其中 `*` 表示该用户禁用，`!!` 表示用户密码未初始化，如果为空，表示密码为
- 最后一次修改密码距离1970年1月1日的天数间隔
- 密码最短有效期
- 密码最长有效期
- 密码过期前几天进行警告
- 账户过期后，被锁定的天数
- 账号失效时间距离1970年1月1日的天数间隔
- 未分配功能

## 查看组信息

> cat /etc/group

输出如:

- `root:x:0:`
- `wheel:x:10:yutiy`
- `yutiy:x:1000:`

组信息显示的有 4 个字段，以 `root` 为例:

- 组名称: root
- 组密码占位符: 统一用 x 替代
- 组id
- 组成员

**注:** 一个用户只能拥有一个主要组，最多可拥有31个附加组。主要组是用户创建文件时默认的的所属组，附加组主要用来权限管理。

## 特殊组wheel -> 管理员的组

将普通用户加入到 wheel 组中，被加入的这个普通用户就成了管理员组内的用户了，然后可以修改配置文件使得只有 wheel 组内的用户可以切换到 root 用户，这样可以避免一些不必要的安全隐患。

# 用户和组信息管理(`/etc/login.defs`)

## 用户管理

> 新建用户时系统会做的三件事:

- 将 `/etc/skel` 中的目录及文件拷贝到新建用户的家目录中
- 在 `/var/spool/mail` 中新建用户名的邮箱
- 在 `/etc` 下的 `passwd, shadow, group` 中增加用户信息

> 添加用户时可指定的参数

- 用户组: `-g` 指定
- 附加组: `-G` 指定
- 用户id: `-u` 指定
- 家目录: `-d` 指定
- 创建的用户没有登录系统的权限: `-s /sbin/nologin` 指定

> 删除用户

```bash
$ userdel -r yutiy    # 删除用户家目录和邮箱，同时删除 passwd、shadow 和 group 文件中的用户信息
$ userdel yutiy      # 只删除 passwd、shadow 和 group 文件中的用户信息
```

> 修改账户密码

```bash
$ passwd [name]
```

- name 为 `root`: 不需要知道当前的密码,并且不需要进行密码校验
- name 为 普通用户: 需要知道当前密码，进行密码校验(1.不能少于8个字符，2.满足复杂度要求)

> 修改账户属性

```bash
$ usermod [options] [name]
```

options参数说明:

- `-s`: 修改用户的登陆shell
- `-L`: 账户锁定
- `-U`: 账户解锁
- `-g`: 修改账户所在组
- `-G`: 给账户添加附加组，不加 `-a` 的话就是替换
- `-a`: 默认情况下，当用户已经存在附加组时，再添加附加组则会把之前的附加组给替换了，加 -a 参数，则不替换原来的附加组，意味着该用户可以有多个附加组

> 锁定和解锁用户

- 锁定用户: `usermode -L yutiy` 或 `passwd -L yutiy`
- 解锁用户: `usermode -U yutiy` 或 `passwd -U yutiy`
- 查看用户状态: `passwd -S yutiy`

`usermod` 与 `passwd` 的区别:

- `passwd` 命令操作完会有提示
- `passwd` 比 `usermod` 权限要大，使用 `usermod` 锁定的用户可以用 `passwd` 来解锁，但是使用 `passwd` 锁定的用户不能用 `usermod` 来解锁

## 组管理

> 添加组

```bash
$ groupadd [options] [name]
```

options可用参数如下:

- `-g, --gid`: 为新组使用设置 gid
- `-K, --key`: 不使用 `/etc/login.defs` 中的默认值
- `-o, --non-unique`: 允许创建有重复 gid 的组
- `-p, --password`:  为新组使用此加密过的密码
- `-r, --system`: 创建一个系统账户

> 删除组

```bash
$ groupdel `-r, --remove` [name]    # -r表示删除主目录和邮件池，只能删除附加组，而不能删除主组!!!
```

> 修改组

```bash
$ groupmod [options] [name]
```

options可用参数如下:

- `-g, --gid GID`: 修改组id
- `-n, --new-name`: 修改组名称
- `-o, --non-unique`: 允许使用重复的 gid

> 修改组中的用户

```bash
$ groupmems -a yutiy -g wheel     # 将用户 yutiy 加入到 wheel 组中
$ groupmems -d yutiy -g wheel     # 将用户 yutiy 从 wheel 组中删除，也可使用 gpasswd -d yutiy wheel 进行删除
```

# 文件权限

## 查看文件权限

使用 `ls -al` 可以查看文件的具体信息，如:

- `-rw-------   1 root root 8574 9月  11 17:18 .bash_history`
- `-rw-r--r--.  1 root root   18 12月 29 2013 .bash_logout`

以 `bash_logout` 为例,解释如下:

- 第一个字符代表文件（-）、目录（d），链接（l） 设备（C） 块设备（b）
- 第一组rw：文件所有者的权限是读、写
- 第二组r--：与文件所在组同一组的用户的权限是读
- 第一组r--：不与文件所有者同组的其他用户的权限是读
- ACL扩展权限: `.`表示没有扩展权限，`+` 表示有

## 文件权限修改

> 修改文件权限 chmod

```bash
$ chmod 755 test                        # 赋予 test 权限 rwxr-xr-x
$ chmod u=rwx, g=rx, o=rx test         # 赋予 test 权限 rwxr-xr-x。u=用户权限，g=组权限，o=不同组其他用户权限
$ chmod u-x, g+w test                   # 给 test 去除用户执行的权限，增加组写的权限
$ chmod a+r test                        # 给所有用户添加读的权限
```

> 修改文件的所有者 chown 和 所属组 chgrp

```bash
# `-R` 表示递归修改文件夹的文件的所属组或所有者
$ chown -R yutiy test         # 修改 test 的所有者为 yutiy
$ chgrp -R wheel test         # 修改 test 的所属组为 wheel
$ chown -R yutiy:wheel test   # 修改 test 的所有者为 yutiy，所属组为 wheel
```

## ACL控制权限 `setfacl, getfacl`

`setfacl`设置文件访问控制规则，参数如下:

- `-m`: 给文件添加扩展ACL规则，*setfacl -m u:yutiy:r test*
- `-x`: 给文件移除扩展ACL规则，*setfacl -x u:yutiy test*
- `-b`: 移除文件的所有ACL规则，*setfacl -b u:yutiy test*
- `-R`: 递归对所有目录内的所有文件和目录进行操作，*setfacl —R -m u:yutiy:r test*
- `-d`: 设置默认的ACL规则

用 `root` 用户新建一个文件 `test.txt`, 其权限为: **-rw-r--r-- 1 root root 4 Sep 12 10:30 test.txt**

> getfacl test.txt

输出信息如下:

```bash
# file: test.txt
# owner: root
# group: root
user::rw-
group::r--
other:r--
```

可见其他用户对其只有查看权限，现在让用户 `yutiy` 拥有 `rw` 权限，别的用户不变:

> setfacl -m u:yutiy:rw test.txt

设置完ACL权限后，文件 `test.txt` 的组权限位发生变化，就变成: **-rw-rw-r--+ 1 root root 4 Sep 12 10:30 test.txt**

> getfacl test.txt

输出信息如下:

```bash
# file: test.txt
# owner: root
# group: root
user::rw-
user:yutiy:rw-    # 用户 yutiy 的 ACL 权限
group::r--
mask::rw-         # 用户之前的权限与 ACL 设置的权限进行运算
other:r--
```

## umask、suid、sgid、粘滞位

> umask

umask 值是可以手动修改的，root用户的 umask 值默认为 `0022`, 普通用户的 umask 值默认 `0002`。其中第一位是特殊位，配置了 `suid(4)、sgid(2)、粘滞位(1)` 才有值。

root用户和普通用户不同之处在于root用户的属组位置的 `w` 只在自己手中，而普通用户的属组权限只要是和它一个组内，就拥有 `w` 权限：
- root 用户去创建一个文件夹的时候，其权限是 `777-022=755`, 而创建一个文件的时候，其权限就是 `755-111=644`
- 普通用户去创建一个文件夹的时候，其权限是 `777-002=775`, 而创建一个文件的时候，其权限就是 `775-111=664`


> suid

当设置了 `suid` 后，`umask` 第一位为 4，其出现在文件所属主权限的执行位上面，标志为`s`。
其作用是让执行该命令的用户以该命令拥有者的权限去执行，比如说当普通用户执行 `passwd` 时会拥有 `root` 权限，这样就可以修改 `/etc/passwd` 这个文件。

```bash
$ ls -al /bin/vim
-rwxr-xr-x 1 root root 100 Sep 12 2019 /bin/vim

$ chmod u+s /bin/vim
$ ls -al /bin/vim
-rwsr-xr-x 1 root root 100 Sep 12 2019 /bin/vim

$ chmod u-s /bin/vim
$ ls -al /bin/vim
-rwxr-xr-x 1 root root 100 Sep 12 2019 /bin/vim
```

使用`suid`需要满足一下几个条件:

- suid只对可执行文件有效
- 调用者对该文件拥有执行权
- 在执行过程中，调用者会暂时获得搞文件的所有者权限，并且只在程序执行过程中有效

> sgid -> chmod g+s /test

当设置了 `sgid` 后，`umask` 第一位为2，它作用于目录，其出现在文件所属组权限的执行位上面，标志位为`s`。

当用户 a 对某一目录有 rwx 权限时，该用户就可以在该目录下简历文件，新建文件的所属和所属组继承自 a。当另一个用户也对该目录拥有 rwx 权限时，就可以修改用户 a 创建的文件，而且修改后文件的所属和所属组都会变成 b!!! 但是如果该目录用 sgid 修饰，则所有拥有 rwx 权限的用户在这个目录下简历的文件都是属于这个目录所属的组。当其他用户修改时，有三种情况:

- 当两个用户都是属于 group 组，则修改后的文件的所属和所属组都不变，而且修改文件不是提示 readonly，可以正常修改
- 当两个用户都是属于 other 组，则修改后的文件的所属组不变，所属会变成另一个用户，修改文件时提示 readonly，必须强制保存退出
- 当一个用户是 group 组，另一个是 other 组，则修改后的文件的所属组不变，所属会变成另一个用户，修改文件时提示 readonly，必须强制保存退出

> 粘滞位 -> chmod o+t /test

当设置了粘滞位后，`umask` 第一位为1，它只能用来修饰一个目录，出现在其他用户权限的执行位(`必须有可执行权限`))上，标志位为`t`。

当某一个目录拥有粘滞位权限时，则任何一个能够在这个目录下建立文件的用户，只有该用户自己和 root 可以修改和删除，其他用户不可以修改和删除，

# linux中的 `sudo、sudo -i、su、su -i` 命令

**只有指定的一些用户才具有执行 `sudo` 的权限，具体配置在 `/etc/sudoers` 文件中**，两个方法可以做到:

- 将改用户加入到 `wheel` 组中（因为 `/etc/sudoers` 中默认加入了 `wheel` 组中的用户可以使用 `sudo` 权限）
- 在 `/etc/sudoers` 文件中加入 `yutiy ALL=(ALL) ALL`

> sudo

暂时切换到超级用户以执行超级用户权限，提示输入密码时为当前用户密码。缺点是每次执行超级用户权限都要在命令前加上 `sudo`，优点是在当前终端再使用 `sudo` 不再要重新输入密码

> sudo -i

为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时为当前用户密码，没有时间限制。执行命令后提示符变为 `#` 而不是 `$`，想要退回普通账户时可以执行 `exit` 或 `logout`

> su

切换到某某用户模式，提示输入密码时的密码为切换后账户的密码，用法为 `su 账户名称`, 如果不加账户名称则默认为 `root`，没有时间限制

> su -

和 `su` 的不同之处在于，`su -`切换后的目录为切换后目录的家目录，而 `su` 则是原始目录

