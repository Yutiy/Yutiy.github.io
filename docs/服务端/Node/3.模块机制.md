---
title: '模块机制'
date: 2020-03-26
permalink: 'node/module'
tag:
  - node
categories:
  - node
---

## Node模块机制

### 请介绍一下node里的模块是什么

Node中，每个文件模块都是一个对象，它定义如下:

```js
// module.js
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  this.filename = null;
  this.loaded = false;
  this.children = [];
}

module.exports = Module;
```

所有的模块都是 Module 的实例。可以看到，当前模块 module.js 也是 Module 的一个实例。

## 请介绍下 require 的模块加载机制

这道题基本上可以了解到面试者对 Node 模块机制的了解程度。

- 先计算模块路径
- 如果模块在缓存里面，取出缓存
- 加载模块
- 输出模块的 exports 属性

```js
// require 内部其实调用 Module._load 方法
Module._load = function(request, parent, isMain) {
  // 计算绝对路径
  var filename = Module._resolveFilename(request, parent);

  // 如果有缓存 -> 取出
  var cacheModule = Module._cache(filename);
  if (cacheModule) {
    return cacheModule.exports;
  }

  // 判断是否为内置模块
  if (NativeModules.exists(filename)) {
    return NativeModules.require(filename);
  }

  // 生成模块实例，存入缓存
  var module = new Module(filename, parent);
  Module._cache(filename, module);

  // 加载模块
  // module.load实际上是Module原型上有一个方法叫Module.prototype.load
  try {
    moudle.load(filename);
    hadExecption = false;
  } finally {
    if (hadException) {
      delete Module._cache[filename];
    }
  }

  // 输出模块的 exports 属性
  return module.exports;
}
```

## 加载模块时，为什么每个模块都有 __dirname, __filename 属性呢？上面 new Module 时没看到这两个属性，从哪里来的呢？

上面一步 `module.load(filename)`, 执行的时候相当于 module 被包装了，包装形式如下:

```js
// 加载js模块（加载node模块和json模块逻辑不一样）
(function(exports, require, module, __filename, __dirname) {
  // 模块源码

  // 模块代码
  var math = require('math');
  exports.math = function(radius) {
    return Math.PI * radius * radius;
  }
})
```

## node中导出模块两种方式，exports.xxx = xxx 和 module.exports = {} 有什么差别？

从上面可以看出 exports 其实就相当于 module.exports。举例如下:

```js
function hello() {
  console.log('Hello, world!');
}
function greet(name) {
  console.log('Hello, ' + name + '!');
}

// module.exports 导出
module.exports = {
  hello: hello,
  greet: greet,
}

// exports导出
exports.hello = hello;
exports.greet = greet;

// 不可以对 exports 进行赋值
// 代码可以执行，但是模块并没有输出任何变量
exports = {
  hello: hello,
  greet: greet,
}
```

为什么会如此呢，可以从 Node 加载机制入手:

```js
// Node把整个待加载的 hello.js 文件放入到一个包装函数 moudle.load 中执行，在执行之前，Node 准备好了 module 变量
var module = {
  id: 'hello',
  exports: {}
}

// load函数最终返回 module.exports
var load = function(exports, module) {
  // hello.js 内容...

  return module.exports;
}
var exports = load(module.exports, module);

// 默认情况下，Node准备的 exports 变量和 module.exports 变量实际上是一个变量，并且初始化为 {}
exports.foo = function () { return 'foo'; };
exports.bar = function () { return 'bar'; };

// 但是，如果要输出的是一个函数或数组，那么只能给 module.exports 赋值，因为给 exports 赋值后，module.exports仍然是空对象{}
module.exports = function () { return 'foo'; };
```

- 如果要输出一个键值对象 {}，可以利用exports这个已存在的空对象 {}，并继续在上面添加新的键值
- 如果要输出一个函数或数组，必须直接对 module.exports 对象赋值
- 建议使用 module.exports = xxx 的方式来输出模块变量，可以应对任何情况
