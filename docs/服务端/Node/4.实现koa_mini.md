---
title: '实现koa_mini'
date: 2019-08-26
permalink: 'node/koa_mini'
tag:
  - node
categories:
  - node
---

## Koa使用分析

```js
const Koa = require('koa');
const app = new Koa();

// koa原型上 use 方法来注册中间件
app.use((ctx, next) => {
  // koa ctx属性上挂载了很多属性
  console.log(ctx.req.url);
  console.log(ctx.request.path);
  console.log(ctx.path);

  next(); // 洋葱模型，中间件组合
})

let responseData = {};
app.use(async (ctx, next) => {
  responseData.name = 'zq';

  console.log(1);
  await next();
  console.log(2);

  ctx.body = responseData;
})

app.use(async (ctx, next) => {
  responseData.age = 23;

  console.log(3);
  await next();
  console.log(4);
})

app.use(async (ctx, next) => {
  responseData.sex = 'female';

  console.log(5);
  await next();
  console.log(6);
})

app.listen(3000);
```

## request封装

request上扩展 query 等属性

```js
const url = require('url');

module.exports = {
  get path() {
    return url.parse(this.req.url).pathname;
  },

  get query() {
    return url.parse(this.req.url, true).query;
  },
}
```

## response封装

response上扩展 body 等属性

```js
module.exports = {
  get body() {
    return this._body;
  },

  /**
   * 设置返回给客户端的 body 内容
   * @param {mixed} data body内容
   */
  set body(data) {
    this._body = data;
  },

  get status() {
    return this.res.statusCode;
  },

  /**
   * 设置返回给客户端的 statusCode
   * @param {number} statusCode 状态码
   */
  set status(statusCode) {
    if (typeof statusCode !== 'number') {
      throw new Error('statusCode must be a number!');
    }
    this.res.statusCode = statusCode;
  }
}
```

## context封装

context 挂载了 request 和 response 对象，并对一些常用方法进行了代理

```js
let proto = {};

function delegateGetter(property, name) {
  proto.__defineGetter__(name, function () {
    return this[property][name];
  });
}

function delegateSetter(property, name) {
  proto.__defineSetter__(name, function (val) {
    this[property][name] = val;
  });
}

// 定义request中要代理的setter和getter
let requestSet = [];
let requestGet = ['path', 'query'];

// 定义response中要代理的setter和getter
let responseSet = ['body', 'status'];
let responseGet = responseSet;

requestGet.forEach(ele => delegateGetter('request', ele));
requestSet.forEach(ele => delegateSetter('request', ele));

responseGet.forEach(ele => delegateGetter('response', ele));
responseSet.forEach(ele => delegateSetter('response', ele));

module.exports = proto;
```

## Koa类的初始化

- Koa是一个类，拥有 middleware、ctx、request、response
- Koa.prototype拥有 use 方法注册中间件
- Koa.prototype拥有 listen 方法监听网络请求，其内部是对 http 模块的封装
- Koa中 handleRequest 方法用于处理上下文 ctx 和中间件 middleware

新建`application.js`:

```js
const http = require('http');
const Stream = require('stream');
const request = require('./request');
const response = require('./response');
const context = require('./context');

class Koa {
  constructor() {
    this.middlewares = [];

    // 原型继承，防止引用
    this.request = Object.create(request);
    this.response = Object.create(response);
    this.context = Object.create(context);
  }

  use(fn) {
    this.middlewares.push(fn);
  }

  createContext(req, res) {
    const ctx = this.context;
    ctx.request = this.request;
    ctx.response = this.response;
    ctx.req = ctx.request.req = req;
    ctx.res = ctx.response.res = res;
    return ctx;
  }

  // 中间件机制
  compose(ctx) {
    return async (ctx) => {
      function createNext(middleware, oldNext) {
        return async () => {
          await middleware(ctx, oldNext);
        }
      }

      // 最后一个中间件的 next 设置为一个立即 resolve 的 promise 函数
      let next = async () => {
        return Promise.resolve();
      };

      let len = this.middlewares.length;
      for(let i = len - 1; i >= 0; i--) {
        let currentMiddleware = this.middlewares[i];
        next = createNext(currentMiddleware, next);
      }

      await next();
    }
  }

  // 对客户端消息进行回复
  responseBody(ctx) {
    const content = ctx.body;
    if (Buffer.isBuffer(content) || typeof content === 'string') {
      ctx.res.setHeader('Content-Type', 'text/plain;chartset=utf8');
      ctx.res.end(content);
    } else if(content instanceof Stream) {
      content.pipe(ctx.res);
    } else if (typeof content === 'object') {
      ctx.res.setHeader('Content-Type', 'application/json;chartset=utf8');
      ctx.res.end(JSON.stringify(content));
    } else {
      ctx.res.end('Not Found');
    }
  }

  // 每一个请求都需要创建一次 context 上下文
  handleRequest(req, res) {
    const ctx = this.createContext(req, res);
    const respond = () => this.responseBody(ctx);

    let fn = this.compose();
    fn(ctx).then(respond);
  }

  listen(...args) {
    const server = http.createServer(this.handleRequest);
    server.listen(...args);
  }
}

module.exports = Koa;
```

## 错误处理

尝试在一个中间件中抛出错误，可以看到浏览器得不到任何响应，已知 fn 是一个 async 函数，执行后返回一个promise，回想 promise 的错误处理是怎样的？没错，只需要定义一个 onerror 函数，里面进行错误发生时候的降级处理，然后在 promise 的 catch 方法中引用这个函数即可。

改造`application.js`如下:

```js
const http = require('http');
const Stream = require('stream');
const EventEmitter = require('events');
const request = require('./request');
const response = require('./response');
const context = require('./context');

class Koa extends EventEmitter {
  constructor() {
    super();
    this.middlewares = [];

    // 原型继承，防止引用
    this.request = Object.create(request);
    this.response = Object.create(response);
    this.context = Object.create(context);
  }

  // ...

  onerror(err, ctx) {
    if (err.code === 'ENOENT') {
      ctx.status = 404;
    } else {
      ctx.status = 500;
    }

    let msg = err.message || 'Internal error';
    ctx.res.end(msg);
    this.emit('error', err);  // 触发error事件
  }

  // 每一个请求都需要创建一次 context 上下文
  handleRequest(req, res) {
    const ctx = this.createContext(req, res);
    const respond = () => this.responseBody(ctx);
    const onerror = (err) => this.onerror(err, ctx);

    let fn = this.compose();
    fn(ctx).then(respond).catch(onerror);
  }

  // ...
}
```

## 参考

[从头实现一个koa框架](https://zhuanlan.zhihu.com/p/35040744)
