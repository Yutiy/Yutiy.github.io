---
title: 'react性能优化'
date: 2020-03-26
permalink: 'react/performance'
tag:
  - react
categories:
  - react
---

React 渲染性能优化大致包含三个方向:

- 减少计算的量 -> 对应到 React 中就是减少渲染的节点或者降低组件渲染的复杂度
- 利用缓存 -> 对应到 React 中就是如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染
- 精确重新计算的范围 -> 对应到 React 中就是绑定组件和状态关系，精确判断更新的 `时机` 和 `范围`，只重新渲染脏组件从而降低渲染范围

## 减少渲染的节点/降低渲染计算量

首先从计算量上下功夫，减少节点渲染的数量或者降低渲染的计算量可以显著提高组件的渲染性能。

### 不要在渲染函数都进行不必要的计算

比如不要在 render 中进行数组排序、数据转换、订阅事件、创建时间处理器等，渲染函数中不应该放置太多副作用。

### 虚拟列表

虚拟列表只渲染当前视口可见元素，其优化的本质就是减少渲染的节点。常用于以下组件场景:

- 无限滚动列表，grid，表哥，下拉列表，spreadsheets
- 无限切换的日历或轮播图
- 大数据量或无限嵌套树
- 聊天窗口，数据口，时间轴

### 惰性渲染

必要时渲染组件，如Tab组件、模态弹窗、折叠组件等

### 选择合适的样式方案

样式运行时性能大概可总结为: CSS > 大部分CSS-in-JS > inline style

## 避免重新渲染

为了避免不必要的组件重新渲染需要做到以下两点:

- 保证组件的纯粹性。即控制组件的副作用，如果组件有副作用则无法安全的缓存渲染结果
- 通过 shouldComponentUpdate/React.memo 生命周期函数来比对 state 和 props，确定是否要重新渲染

另外这些措施也可以帮助更容易地优化组件重新渲染:

### 简化state、props

如果一个组件的 props 太复杂首先需要对组件进行拆解，另外复杂的 props 也会影响 shallowCompare 效率，还会让组件变得难以预测和调试。

state原则: 如果组件响应需要它的变动，或者需要渲染到视图中的数据才应该放到 state 中，这样可以避免不必要的数据变动导致组件重新渲染。

### 不变的事件处理器

避免使用箭头函数形式的事件处理器，例如:

```js
<ComplexComponent onClick={evt => onClick(evt)} />
```

假设 ComplexComponent 是一个复杂的 PureComponent, 这里使用箭头函数，其实每次渲染都会创建一个新的事件处理器，这会导致 ComplexComponent 始终被重新渲染

更好的方式是使用实例方法:

```js
// 类组件
class MyComponent extends Component {
  render() {
    <ComplexComponent onClick={this.handleClick} />
  }

  handleCLick = () => {
    // pass
  }
}

// 函数组件，有时可以考虑用 data-* 属性获取参数
const MyComponent = () => {
  const handleClick = useCallback(() => {
    // pass
  }, [])

  return <ComplexComponent onClick={this.handleClick} />
}
```

### 不可变数据

不可变数据可以让状态变得可预测，也让 shouldComponentUpdate 浅比较变得更可靠和高效。如Immutable.js等工具。

## 精细化渲染

- 响应式数据的精细化渲染: 将数据隔离抽取到单一指责的组件中，这样导致组件重新渲染的数据来源就回变少
- 不滥用context: Conext API的更新特点是可以穿透 React.memo/shouldComponentUpdate 比对的，所以要合理使用
