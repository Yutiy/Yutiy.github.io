---
title: 'http定长及不定长数据传输'
date: 2020-03-26
permalink: 'http/big_transfer'
tag:
  - http
categories:
  - http
---

## 定长包体

对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。

用一个nodejs服务器来模拟一下:

```js
const http = require('http');
const server = http.createServer();

server.on('request', (req, res) => {
  if(req.url === '/') {
    res.setHeader('Content-Type', 'text/plain');
    res.setHeader('Content-Length', 10);
    res.write("helloworld");
  }
})

server.listen(8081, () => {
  console.log("成功启动");
})
```

启动后访问: localhost:8081，浏览器输出 `helloworld`。

这是长度正确的情况，那不正确的情况是如何处理的呢？试着把这个长度设置的小一些:

```js
res.setHeader('Content-Length', 8);
```

重启服务，再次访问，现在浏览器输出: `hellowor`。

那后面的 ld 哪里去了呢？实际上**在 http 的响应体中直接被截去了**。然后我们试着将这个长度设置得大一些:

```js
res.setHeader('Content-Length', 12);
```

重启服务，再次访问，现在**浏览器直接无法显示了**。

可以看到 `Content-Length` 对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。

## 不定长包体

这里就必须介绍另外一个 http 头部字段了:

```
Transfer-Encoding: chunked
```

表示分块传输数据，设置这个字段后会自动产生两个效果:

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

用一个nodejs服务器来模拟一下:

```js
const http = require('http');
const server = http.createServer();

server.on('request', (req, res) => {
  if(req.url === '/') {
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    res.setHeader('Content-Length', 10);
    res.setHeader('Transfer-Encoding', 'chunked');
    res.write("<p>来啦</p>");
    setTimeout(() => {
      res.write("第一次传输<br/>");
    }, 1000);
    setTimeout(() => {
      res.write("第二次传输");
      res.end()
    }, 2000);
  }
})

server.listen(8009, () => {
  console.log("成功启动");
})
```

用 charles 抓到的响应如下:

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf8
Date: Thu, 24 Sep 2020 08:38:32 GMT
Transfer-Encoding: chunked
Proxy-Connection: Keep-alive

d
<p>来啦</p>
14
第一次传输<br/>
f
第二次传输
0
```

注意，`Connection: keep-alive` 及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。

响应体的结构比较有意思，如下所示:

```
chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
......
0

```

最后是留有有一个`空行`的，这一点请大家注意。
