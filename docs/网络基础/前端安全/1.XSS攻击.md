---
title: 'XSS攻击'
date: 2020-03-26
permalink: 'secure/xss'
tag:
  - secure
categories:
  - secure
---

XSS(Cross-Site-Scripting, 跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登录网站时就会执行这些恶意代码，比如读取cookie、session tokens，或者其他敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。其本质是:

- 恶意代码未经过过滤，与网站正常代码混在一起
- 浏览器无法分辨那些脚本是可信的，导致恶意脚本被执行
- 直接在用户终端执行，其可以直接获取用户的信息，利用这些信息冒充用户向网站发起攻击

## 反射型XSS

当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户浏览器上。

> 反射型XSS攻击步骤:

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码
2. 用户打开带有恶意代码 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 HTML 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作

反射型XSS 漏洞常见于通过 `URL` 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意 `URL` 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

> 如何防范反射型XSS攻击:

- 不希望前端拿到cookie，后端可以设置`httpOnly`（不过不是 XSS 攻击的解决方案，只能降低受损范围）
- 对字符串进行编码，如查询参数进行转义后再输出到页面

```js
app.get('/welcome', function(req, res) {
  res.send(`${encodeURIComponent(req.query.type)}`);
})
```

## 存储型XSS

恶意脚本永久存储在目标服务器上。存储型XSS的攻击步骤:

1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，凭借在HTML中返回给浏览器
3. 用户浏览器接收到相应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

> 如何防范存储型XSS攻击

1. 前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)
2. 服务端接收到数据，在存储到数据库之前，进行转义/过滤
3. 前端接收到服务端传递过来的数据，在展示到页面前，先进行转义/过滤

## DOM型XSS

DOM 型 XSS 攻击，实际上是前端 JS 代码不够严谨，把不可信的内容插入到页面。在使用`.innerHTML`、`.outHTML`、`.appendChild`、`document.write()`等API时要注意，不可把不可信的数据作为 HTML 插入到页面上。尽量使用`.innerText`、`.textContent`、`.setAttribute()`等。

> DOM型XSS的攻击步骤

- 攻击者构造出特殊数据，其中包含恶意代码
- 用户浏览器执行了恶意代码
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作

> 如何方法DOM型XSS攻击

防范DOM型XSS攻击的核心就是对输入内容进行转义(DOM中的内联事件监听器和链接跳转都能把字符串作为代码执行，需要对其内容进行检查)。

- 对于`url`链接，可以直接使用`encodeURIComponent`转义
- 对于非`url`，可以进行如下编码:

```js
function encodeHtml(str) {
  return str.replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}
```

**除了谨慎的转义，还需要其他一些手段来防范XSS攻击:**

1. Content Security Policy

在服务端使用 HTTP 的 `Content Security Policy` 头部来指定策略，或者在前端设置 `meta` 标签。例如下面的配置只允许加载同域下的资源:

```bash
Content-Security-Policy: default-src 'self';

# meta 无法 report
<meta http-equiv="Content-Security-Policy" content="form-action 'self';">
```

严格的CSP在XSS的防范中可以起到一下作用：

- 禁止加载外域代码，防止复杂的攻击逻辑
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）
- 合理使用上报可以及时发现 XSS，利于尽快修复问题
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）

2. 输入内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度

3. 输入内容限制

对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。

4. 其他安全措施

- **HTTP-only Cookie**: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie
- **验证码**：防止脚本冒充用户提交危险操作
