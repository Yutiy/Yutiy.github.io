# Gitlab Runner

`Gitlab CI` 最大的作用是管理各个项目的构建状态，因此运行构建任务这种浪费资源的事情就交给了 `Gitlab Runner` 来做。因为 `Gitlab Runner` 可以安装在不同的及其上面，所以在构建任务运行期间不会影响到 `Gitlab` 的性能。

## 注册

- 打开 `Gitlab` 中的项目页面，在项目中找到 `runners`
- 在 `runner` 注册的机器上，用命令行注册，如 `gitlab-runner register --name="XX" --url="https://git.xx.com/" --token="XXX" --executor="docker" --description "My Runner"`
- linux 配置文件在`/etc/gitlab-runner/config.toml`，macos 配置文件在`/Users/home/.gitlab-runner/config.toml`

```bash
concurrent = 1
check_interval = 0

[session_server]
  session_timeout = 1800

[[runners]]
  name = "myTest"
  url = "https://gitlab.com/"
  token = "xxx"
  executor = "docker"
  [runners.custom_build_dir]
  [runners.docker]
    tls_verify = false
    image = "node:latest"
    privileged = false
    disable_entrypoint_overwrite = false
    oom_kill_disable = false
    disable_cache = false
    volumes = ["/cache"]
    shm_size = 0
    [runners.cache]
      [runners.cache.s3]
      [runners.cache.gcs]
```

## Stages

`Stages` 表示构建阶段，也就是流程的意思。默认会有三个stages: `build、test、deploy`。可以在一次 `pipeline` 中定义多个 `stages`，这些 `stages` 有如下特点:

- 所有的 `Stage` 会按照顺序执行
- 只有当所有 `Stage` 完成后，该构建任务才算完成
- 如果中间有一个 `Stage` 失败，那么后面的 `Stage` 都不会执行，该构建任务失败

## Jobs

`Jobs` 表示构建工作，一个 `Stage` 里面可以定义多个 `Job`，这些 `Job` 会有如下特点:

- 相同 `Stage` 里面的 `Job` 会并行执行
- 相同 `Stage` 里面的所有 `Job` 都执行成功，该 `Stage` 才算成功
- 如果任何一个 `Job` 失败，该 `Stage` 就算失败

## .gitlab-ci.yml

`.gitlab-ci.yml` 用来配置 `CI` 要做什么事情，这个文件位于仓库的根目录。

当有新内容 `push` 到仓库后，或者有代码合并后，`Gitlab` 就会查找是否有 `.gitlab-ci.yml` 文件，如果文件存在，`Runners` 将会根据该文件的内容开始构建本次 `commit`。

**示例:**

```yml
# 定义 stages（阶段）。任务将按此顺序执行。
stages:
  - build
  - test
  - deploy

# 定义 job（任务）
job1:
  stage: test
  tags:
    - XX # 只有标签为XX的runner才会执行这个任务
  only:
    - dev    # 只有dev分支提交代码才会执行这个任务。也可以是分支名称或触发器名称
    - /^future-.*$/ # 正则表达式，只有future-开头的分支才会执行
  script:
    - echo "I am job1"
    - echo "I am in test stage"

# 定义 job
job2:
  stage: test   # 如果此处没有定义stage，其默认也是test
  only:
    - master    # 只有master分支提交代码才会执行这个任务
  script:
    - echo "I am job2"
    - echo "I am in test stage"
  allow_failure: true # 允许失败，即不影响下步构建

# 定义 job
job3:
  stage: build
  except:
    - dev # 除了dev分支，其它分支提交代码都会执行这个任务
  script:
    - echo "I am job3"
    - echo "I am in build stage"
  when: always # 不管前面几步成功与否，永远会执行这一步。它有几个值：on_success （默认值）\on_failure\always\manual（手动执行）

# 定义 job
.job4:    #对于临时不想执行的job，可以选择在前面加个"."，这样就会跳过此步任务，否则你除了要注释掉这个jobj外，还需要注释上面为deploy的stage
  stage: deploy
  script:
    - echo "I am job4"

# 模板，相当于公用函数，有重复任务时很有用
.job_template: &job_definition  # 创建一个锚，'job_definition'
  image: ruby:2.1
  services:
    - postgres
    - redis

test1:
  <<: *job_definition           # 利用锚'job_definition'来合并
  script:
    - test1 project

test2:
  <<: *job_definition           # 利用锚'job_definition'来合并
  script:
    - test2 project

# 下面几个都相当于全局变量，都可以添加到具体job中，这时会被子job的覆盖
before_script:
  - echo "每个job之前都会执行"

after_script:
  - echo "每个job之后都会执行"

variables:    # 变量
  DATABASE_URL: "postgres://postgres@postgres/my_database"  # 在job中可以用${DATABASE_URL}来使用这个变量。常用的预定义变量有CI_COMMIT_REF_NAME（项目所在的分支或标签名称），CI_JOB_NAME（任务名称），CI_JOB_STAGE（任务阶段）
  GIT_STRATEGY: "none" # GIT策略，定义拉取代码的方式，有3种：clone/fetch/none，默认为clone，速度最慢，每步job都会重新clone一次代码。我们一般将它设置为none，在具体任务里设置为fetch就可以满足需求，毕竟不是每步都需要新代码，也不符合我们测试的流程

cache:    # 缓存
  # 因为缓存为不同管道和任务间共享，可能会覆盖，所以有时需要设置key
  key: ${CI_COMMIT_REF_NAME}  # 启用每分支缓存。
  # key: "$CI_JOB_NAME/$CI_COMMIT_REF_NAME" # 启用每个任务和每个分支缓存。需要注意的是，如果是在windows中运行这个脚本，需要把$换成%
  untracked: true    # 缓存所有Git未跟踪的文件
  paths:    # 以下2个文件夹会被缓存起来，下次构建会解压出来
    - node_modules/
    - dist/
```
